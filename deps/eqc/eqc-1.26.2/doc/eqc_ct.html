<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module eqc_ct</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eqc_ct</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul> 
This module embeds a file with QuickCheck properties into a test SUITE for 
the common-test framework.

<p><b>Version:</b> 1.26.2</p>

<h2><a name="description">Description</a></h2><p> 
This module embeds a file with QuickCheck properties into a test SUITE for 
the common-test framework.</p>

 Each property exported from a BEAM file corresponds to a test in common test.
 However, properties with arguments cannot automatically be initialized with
 meaningful values. Therefore, only the properties of arity zero are transformed
 to test cases.
 This means that whenever you have a property of arity larger than zero in your
 _eqc file, you should provide another property of arity zero that embeds that
 property.
 For example, we have a property to check encryption and decryption of messages.
 For encryption we need a key and we need the same key to decrypt. However, the
 key must be a prime number of 64 bits. Since we want to check the encryption on
 some real keys, we created the following property:
 <pre> prop_communicate(Key) -&gt;
    ?FORALL(Msg,message(),
            decode(Key,encode(Key,Msg)) == Msg).</pre>
 Now for automatic testing, we like to add an extra property that
 chooses a specific configuration,
 or a number of them, and test the above property in that configuration.
 <pre> prop_communicate() -&gt;
    prop_communicate(&lt;&lt;41:64&gt;&gt;).</pre>
 Or, alternatively, with a bit more randomness:
 <pre> prop_communicate() -&gt;
    ?FORALL(Key,key(),
            prop_communicate(Key).</pre><p> 
where we make a key generator that either picks a key from a given list of keys 
or (expensive) creates a valid key.</p>

 <p>Thus, given a module, all exported functions of arity zero starting with
  <b>prop_</b> are used to create test cases from, by calling quickcheck on 
those properties.</p>

 We start from a BEAM file, since we only need exported properties. However,
 it is very useful in common test to see the source of the property as well.
 Therefore, if the source of the property is included in the BEAM file (via
 compile flag <i>debug_info</i>), then
 we add it as comments to the SUITE. The choice to add it as comments instead
 of source code is motivated by stressing that the code in the module containing
 the properties is the final form of specification, and in addition by the
 technical problem of preventing name conflicts.

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#compile-1">compile/1</a></td><td>Equivalent to <a href="#compile-2"><tt>compile(Module, [])</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#compile-2">compile/2</a></td><td>Given a compiled module, a common test SUITE is generated as BEAM file
 that calls all properties with zero arity in that module as test
 cases.</td></tr>
<tr><td valign="top"><a href="#compile_mods-1">compile_mods/1</a></td><td>Given a list of module names, the function <a href="#compile-1"><code>compile/1</code></a>
 is called on each of these.</td></tr>
<tr><td valign="top"><a href="#module-1">module/1</a></td><td>Given a compiled module, a common test SUITE is generated as syntax tree
 in which all properties with zero arity in that module are called as test
 cases.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="compile-1">compile/1</a></h3>
<div class="spec">
<p><tt>compile(Module::atom()) -&gt; {ok, ModuleName::atom()} | error</tt></p>
</div><p>Equivalent to <a href="#compile-2"><tt>compile(Module, [])</tt></a>.</p>


<h3 class="function"><a name="compile-2">compile/2</a></h3>
<div class="spec">
<p><tt>compile(Module::atom(), Options::[Option::<a href="#type-option">option()</a>]) -&gt; {ok, ModuleName::atom()} | error</tt></p>
</div><p><p>Given a compiled module, a common test SUITE is generated as BEAM file
 that calls all properties with zero arity in that module as test
 cases.
 Properties should all start with <em>prop_</em> in
 order to be recognized as properties and are translated to
 <em>check_prop_...</em> as test case. 
The options one can provide are the same options as those for compile:file/2. 
In addition one may provide the option {properties,[Names::atom()]} in which 
Names represent the function names that should be considered as properties. This 
is only useful if you diverted from the convention to call properties prop_....</p>

 <p>With the compiler option {outdir,Dir} one can specify in which directory the 
generated BEAM file should be created.</p>

 If <tt>Module</tt> contains any of the common test callbacks
 <tt>init_per_suite/1, end_per_suite/1, init_per_testcase/2,
 end_per_testcase/2</tt> they will be called by the corresponding callbacks in
 the generated suite. Note that <tt>init_per_group</tt> and
 <tt>end_per_group</tt> are not supported.</p>

<h3 class="function"><a name="compile_mods-1">compile_mods/1</a></h3>
<div class="spec">
<p><tt>compile_mods(Modules::[Module::atom()]) -&gt; {ok, [ModuleName::atom()]} | error</tt></p>
</div><p>Given a list of module names, the function <a href="#compile-1"><code>compile/1</code></a>
 is called on each of these. This is in particular useful if run from the
 command line with the erl -s option.</p>

<h3 class="function"><a name="module-1">module/1</a></h3>
<div class="spec">
<p><tt>module(Module::atom()) -&gt; <a href="#type-syntaxTree">syntaxTree()</a></tt></p>
</div><p><p>Given a compiled module, a common test SUITE is generated as syntax tree
 in which all properties with zero arity in that module are called as test
 cases.
 Properties should all start with <em>prop_</em> in
 order to be recognized as properties and are translated to
 <em>check_prop_...</em> as test case.</p>

 One can use erl_prettypr:format(module(Module)) to get a printed
 output of the source code.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jun 20 2012, 10:22:56.</i></p>
</body>
</html>
