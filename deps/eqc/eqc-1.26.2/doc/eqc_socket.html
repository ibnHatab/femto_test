<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module eqc_socket</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eqc_socket</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module provides functions for testing software via a socket interface.
<p>Copyright © Quviq AB, 2007-2008</p>

<p><b>Authors:</b> Thomas Arts.</p>

<h2><a name="description">Description</a></h2><p>This module provides functions for testing software via a socket interface.
 The module eqc_socket is with advantage used together with
 <a href="eqc_statem.html"><code>eqc_statem</code></a>. 
A state machine defined by eqc_statem can be used as test model for 
software that is accessed via a socket interface, i.e., the software undertest 
is accessed via a socket interface and the model used to test it is defined 
as a state machine.</p>

 <p>The functions in this module provide a process interface to a socket.
 Instead of directly communicating to a socket, one creates a process that
 "owns" the socket by <i>connect</i>. One can send data to the socket via
 <i>send</i>
 and <i>send_receive</i>, the first for asynchronous and the
 second for synchronous communication. A trace of messages send from and
 to the socket is collected by the process "owning" the socket. This
 trace can be obtained by <i>get_trace</i> and arbitrary events can be
 added to the trace by <i>event</i>.</p>

 <p>The process communicating with the socket is using the standard gen_tcp 
commands, for details on options that can be provided we refer to the 
documentation of gen_tcp and inet.</p>

 <p>
 Example of a property using eqc_socket in combination with <a href="eqc_statem.html"><code>eqc_statem</code></a>:
 <pre> ?FORALL(Cmds,commands(?MODULE),
         begin
           Socket = eqc_socket:connect("localhost",4567,[binary]),
           {H,S,Res} == run_commands(?MODULE,Cmds,[{socket,Socket}]),
           Trace = eqc_socket:get_trace(Socket),
           eqc_socket:close(Socket),
           Res==ok andalso valid(Trace)
         end)&lt;/pre&gt;</pre>
 </p>
 <h3>Traces</h3>
 <p>
 In case you test software by communicating with it over a socket, it
 may be the case that there is no one-to-one map from each sent message
 to each message received. The application under test
 may sent spontaneous information
 to the socket or it may send no answer at all to certain messages.
 In case of this kind of asynchronous communication, one sends a sequence
 of messages and analyses the received sequence thereafter by validating
 whether the received sequence makes sense given the sent sequence.
 </p>
 <p>
 The sequence of all messages sent and received together with user defined
 events is stored in a list, called trace. The data type for events is
 a record <b>#eqc_socket_event</b> and access functions to this record are
 defined in this module, viz.
 event_origin, event_abstract, event_content, and event_timestamp.
 </p>
 <h3>Abstractions</h3>
 <p>
 Analysis of traces is less work if there is a simple abstraction of
 events (or messages) present in the trace. For example, analysing a
 sequence <i>add, add, modify, sub, sub</i> on whether or not we always
 subtract as many items as we add is relatively easy. However, if the
 atoms in that sequence are textual XML messages that need a regular
 expression map to see whether it is an addition or subtraction, then
 we have to program more and perform more work.
 </p>
 <p>
 Therefore, traces have a representation for both abstract and
 concrete form of each message and event. Of course, an abstraction has
 to be provided manually. When sending messages and events one can specify
 this abstraction directly. For received messages, abstraction has to be
 defined separately.
 </p>
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#close-1">close/1</a></td><td>Closes the socket connection and terminates the process that "owned" the
 open connection.</td></tr>
<tr><td valign="top"><a href="#connect-3">connect/3</a></td><td>Creates a process with an open socket connection.</td></tr>
<tr><td valign="top"><a href="#event-2">event/2</a></td><td>Equivalent to <a href="#event-3"><tt>event(Socket, Event, Event)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#event-3">event/3</a></td><td>Adds an event to the trace created by the socket "owner".</td></tr>
<tr><td valign="top"><a href="#event_abstract-1">event_abstract/1</a></td><td>return event data: abstraction of the event.</td></tr>
<tr><td valign="top"><a href="#event_content-1">event_content/1</a></td><td>return event data: real data in event.</td></tr>
<tr><td valign="top"><a href="#event_origin-1">event_origin/1</a></td><td>return event data: originator of the event.</td></tr>
<tr><td valign="top"><a href="#event_timestamp-1">event_timestamp/1</a></td><td>return event data: timestamp of the event.</td></tr>
<tr><td valign="top"><a href="#get_trace-2">get_trace/2</a></td><td>Returns messages send and received by the socket plus addional events
 added by <i>event</i>.</td></tr>
<tr><td valign="top"><a href="#send-2">send/2</a></td><td>Equivalent to <a href="#send-3"><tt>send(Socket, send, Message)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#send-3">send/3</a></td><td>Send a message to the specified Socket.</td></tr>
<tr><td valign="top"><a href="#send_receive-2">send_receive/2</a></td><td>Equivalent to <a href="#send_receive-3"><tt>send_receive(Socket, send, Message)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#send_receive-3">send_receive/3</a></td><td>Send a message to the specified Socket and wait for a reply message.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="close-1">close/1</a></h3>
<div class="spec">
<p><tt>close(Socket::pid()) -&gt; ok | {error, Reason::<a href="#type-posix">posix()</a>}</tt></p>
</div><p>Closes the socket connection and terminates the process that "owned" the
 open connection.
 Note that trace data cannot be collected after that the socket has been
 closed!</p>

<h3 class="function"><a name="connect-3">connect/3</a></h3>
<div class="spec">
<p><tt>connect(Host::<a href="#type-ip_address">ip_address()</a>, Port::integer(), Options::[<a href="#type-option">option()</a>]) -&gt; pid()</tt></p>
</div><p>Creates a process with an open socket connection. The socket is
 connected by calling gen_tcp:connect/3.
 This function has a timeout of 1 second on trying to create the connection.</p>

<h3 class="function"><a name="event-2">event/2</a></h3>
<div class="spec">
<p><tt>event(Socket::pid(), Event::term()) -&gt; ok</tt></p>
</div><p>Equivalent to <a href="#event-3"><tt>event(Socket, Event, Event)</tt></a>.</p>


<h3 class="function"><a name="event-3">event/3</a></h3>
<div class="spec">
<p><tt>event(Socket::pid(), AbsEvent::term(), Event::term()) -&gt; ok</tt></p>
</div><p>Adds an event to the trace created by the socket "owner".
 The function has a timeout of 1 second in case the socket owner
 does not respond.</p>

<h3 class="function"><a name="event_abstract-1">event_abstract/1</a></h3>
<div class="spec">
<p><tt>event_abstract(Eqc_socket_event::<a href="#type-eqc_socket_event">eqc_socket_event()</a>) -&gt; term()</tt></p>
</div><p>return event data: abstraction of the event.</p>

<h3 class="function"><a name="event_content-1">event_content/1</a></h3>
<div class="spec">
<p><tt>event_content(Eqc_socket_event::<a href="#type-eqc_socket_event">eqc_socket_event()</a>) -&gt; term()</tt></p>
</div><p>return event data: real data in event.</p>

<h3 class="function"><a name="event_origin-1">event_origin/1</a></h3>
<div class="spec">
<p><tt>event_origin(Eqc_socket_event::<a href="#type-eqc_socket_event">eqc_socket_event()</a>) -&gt; term()</tt></p>
</div><p>return event data: originator of the event.</p>

<h3 class="function"><a name="event_timestamp-1">event_timestamp/1</a></h3>
<div class="spec">
<p><tt>event_timestamp(Eqc_socket_event::<a href="#type-eqc_socket_event">eqc_socket_event()</a>) -&gt; term()</tt></p>
</div><p>return event data: timestamp of the event.</p>

<h3 class="function"><a name="get_trace-2">get_trace/2</a></h3>
<div class="spec">
<p><tt>get_trace(Socket::pid(), Delay::<a href="#type-int">int()</a>) -&gt; <a href="#type-trace">trace()</a></tt></p>
</div><p>Returns messages send and received by the socket plus addional events
 added by <i>event</i>. The delay specified is time in milliseconds that the
 process waits before it returns all messages that it the socket has received.
 <p>
 Value for the delay is application and connection specific, one can start
 with a value of 200 and see whether the application responds sufficiently
 fast. One can also generate a timeout value in the property by using
 ?LET(TimeOut,choose(0,1000), 1000-TimeOut). This value can be used
 to check a simple property, e.g., that after sending a message has been
 received. This value will shrink to least neccessary timeout to
 receive a response.
 </p></p>

<h3 class="function"><a name="send-2">send/2</a></h3>
<div class="spec">
<p><tt>send(Socket::pid(), Message::binary() | string()) -&gt; ok | {error, <a href="#type-posix">posix()</a>}</tt></p>
</div><p>Equivalent to <a href="#send-3"><tt>send(Socket, send, Message)</tt></a>.</p>


<h3 class="function"><a name="send-3">send/3</a></h3>
<div class="spec">
<p><tt>send(Socket::pid(), AbstractMessage::term(), Message::binary() | string()) -&gt; ok | {error, <a href="#type-posix">posix()</a>}</tt></p>
</div><p>Send a message to the specified Socket.
 Make sure the message is
 binary in case socket expects a binary.
 AbstractMessage is an abstraction of the message that will be included in
 the trace. The value returned is the same as returned by send in gen_tcp.
 The function has a timeout of 1 second in case the socket owner does not
 respond.</p>

<h3 class="function"><a name="send_receive-2">send_receive/2</a></h3>
<div class="spec">
<p><tt>send_receive(Socket::pid(), Message::binary() | string()) -&gt; {ok, Reply::binary() | string()} | {error, <a href="#type-posix">posix()</a>}</tt></p>
</div><p>Equivalent to <a href="#send_receive-3"><tt>send_receive(Socket, send, Message)</tt></a>.</p>


<h3 class="function"><a name="send_receive-3">send_receive/3</a></h3>
<div class="spec">
<p><tt>send_receive(Socket::pid(), AbstractMessage::term(), Message::binary() | string()) -&gt; {ok, Reply::binary() | string()} | {error, <a href="#type-posix">posix()</a>}</tt></p>
</div><p>Send a message to the specified Socket and wait for a reply message.
 Make sure the message is
 binary in case socket expects a binary.
 AbstractMessage is an abstraction of the message that will be included in
 the trace.
 The error value returned is the same as returned by send in gen_tcp.
 The function has a timeout of 1 second in case the socket owner or
 application does not respond.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jun 20 2012, 10:22:56.</i></p>
</body>
</html>
